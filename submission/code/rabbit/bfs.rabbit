(define (mod a m) (- a (* (/ a m) m)))
(define (inc x) (+ x 1))
(define (dec x) (- x 1))
(define (min x y) (if (> x y) y x))
(define (null? ls) (atom? (cdr ls)))
(define (and a b) (* a b))
(define (or a b) (+ a b))
(define (not a) (- 1 a))
(define (at v i) (if (= 0 i) (car v) (at (cdr v) (dec i))))
(define (search f ls) (if (f (car ls)) 0 (inc (search f (cdr ls)))))
(define (tail ls) (if (null? (cdr ls)) (car ls) (tail (cdr ls))))

(define (reverse ls)
  (let ((f (lambda (ls a) (if (null? ls)
      a
      (f (cdr ls) (cons (car ls) a))))))
  (f ls (cons 0 0))))
(define (map f ls)
  (if (null? ls) ls (cons (f (car ls)) (map f (cdr ls)))))
(define (map2 f ls)
  (if (atom? (cdr ls))
    (cons (f (car ls)) (cdr ls))
    (cons (f (car ls)) (map2 f (cdr ls)))))

(define (adjust-list ls nothing len) ; クソなリスト形式から固定長リストに.
  (let ((flag 0)
        (f (lambda (ls nothing len)
             (if (= 0 len) (cons -1 -1)
               (if (= 0 flag)
                 (cons (car ls)
                       (if (atom? (cdr ls))
                         (begin (set! flag 1) (f ls nothing (dec len)))
                         (f (cdr ls) nothing (dec len))))
                 (cons nothing (f ls nothing (dec len)))
                 )))))
    (f ls nothing (inc len))))
(define (make-tree ls depth)
  (let ((mk (lambda (dep)
              (if (= 0 dep)
                (let ((x (car ls)))
                  (begin (set! ls (cdr ls)) x))
                (cons (mk (- dep 1)) (mk (- dep 1)))))))
    (mk depth)
    )
  )
(define (read-tree t i pow2depth-1) ; 2 の (depth - 1) 乗
  (if (= 0 pow2depth-1)
    t
    (if (> pow2depth-1 i)
      (read-tree (car t) i (/ pow2depth-1 2))
      (read-tree (cdr t) (- i pow2depth-1) (/ pow2depth-1 2)))))

(define (set-tree t i x pow2depth-1) ; 2 の (depth - 1) 乗
  (if (= 0 pow2depth-1)
    x
    (if (> pow2depth-1 i)
      (cons (set-tree (car t) i x (/ pow2depth-1 2)) (cdr t))
      (cons (car t) (set-tree (cdr t) (- i pow2depth-1) x (/ pow2depth-1 2))))))

(define (make-field raw-ls)
  (begin
    (set! raw-ls (map2 (lambda (row) (adjust-list row -1 32)) raw-ls))
    (set! raw-ls (adjust-list raw-ls (adjust-list (cons -1 -1) -1 32) 32))
    (make-tree (map (lambda (row) (make-tree row 5)) raw-ls) 5)
    ))

(define (map-field f field)
  (if (atom? field) (f field)
  (cons (map-field f (car field)) (map-field f (cdr field)))))

(define (read-field field i j)
  (read-tree (read-tree field i 16) j 16))
(define (set-field field i j x)
  (set-tree field i (set-tree (read-tree field i 16) j x 16) 16))



; queue : (front (reversed tail))
; push-tail, pop-front
(define (queue-push q x) (cons (car q) (cons x (cdr q))))
(define (queue-empty? q) (and (null? (car q)) (null? (cdr q))))
(define (queue-rebalance q)
  (if (null? (car q))
    (cons (reverse (cdr q)) (car q))
    q))
(define (queue-top q) (car (car q)))
(define (queue-pop q) (cons (cdr (car q)) (cdr q)))

;(define (queue-pop q) ; return (x, queue)
;  (if (null? (car q))
;    (queue-pop (cons (reverse (cdr q)) (car q)))
;    (cons (car (car q)) (cons (cdr (car q)) (cdr q)))))

(define (adjacent y x)
  (cons (cons (dec y) x)
  (cons (cons y (inc x))
  (cons (cons (inc y) x)
  (cons (cons y (dec x))
        (cons -1 -1))))))


(main (world ghost) (begin
      (cons 99 (lambda (arg)
                 (main (state world) (begin
(let ((seed state)
      (rng (lambda (_) (let ((next (mod (+ (* seed 5) 89219821) 1000000009)))
                         (begin (set! seed next) next))))
      (field (make-field (car world)))
      (q (cons (cons 0 0) (cons 0 0)))
      )
  (let ((nstate (rng 0))
        (dist (map-field (lambda (x) 33554432) field))
        (x 0)
        (y 0)
        (d 0)
        (lambdax (car (car (cdr (car (cdr world))))))
        (lambday (cdr (car (cdr (car (cdr world))))))
        (yyxx 0)
        (xx 0)
        (yy 0)
        (dd 0)
        (res 0)
        (func 0)
        (topo 0)
        (adj 0)
        (objective 0)
        (gomi 0)
        )
  (let ((bfs (lambda (_) (begin (set! q (queue-rebalance q))
            (if (queue-empty? q) (cons -1 -1)
              (begin
                (set! y (queue-top q))
                (set! q (queue-pop q))
                (set! x (queue-top q))
                (set! q (queue-pop q))
                (set! d (inc (read-field dist y x)))
                (set! gomi (map (lambda (yyxx)
                    (begin
                      (set! yy (car yyxx))
                      (set! xx (cdr yyxx))
                      (set! dd (read-field dist yy xx))
                      (if (and (> dd d) (not (= 0 (read-field field yy xx))))
                        (begin
                          (set! q (queue-push q yy))
                          (set! q (queue-push q xx))
                          (set! dist (set-field dist yy xx d))
                          0
                          )
                        0))
                    ) (adjacent y x)))
                (cons (cons y x) (bfs 0))
               )))))
        (restore (lambda (yx) (begin
                (set! d (dec (read-field dist (car yx) (cdr yx))))
                (if (= 0 d) (cons yx (cons -1 -1)) (begin
                    (set! func (lambda (yyxxs)
                           (begin
                             (set! yy (car (car yyxxs)))
                             (set! xx (cdr (car yyxxs)))
                             (set! dd (read-field dist yy xx))
                             (if (= dd d) (cons yy xx) (func (cdr yyxxs))))))
                    (set! yyxx (func (adjacent (car yx) (cdr yx))))
                    (cons yx (restore yyxx)))
                ))))
        ) (begin
        (set! q (queue-push q lambday))
        (set! q (queue-push q lambdax))
        (set! dist (set-field dist lambday lambdax 0))
        (set! topo (bfs 0))
        (set! objective (search (lambda (yx)
                (let ((v (read-field field (car yx) (cdr yx))))
                  (or (= v 2) (= v 3)))
                                 ) topo))
        (set! objective (at topo objective))
        (set! res (tail (restore objective)))
        (set! adj (adjacent lambday lambdax))
        (set! res (search (lambda (yx)
                            (and (= (car yx) (car res))
                                 (= (cdr yx) (cdr res)))) adj))
        (cons 0 res)
    )
    ))
  )
                       ))
                 ))))

