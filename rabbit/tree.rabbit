(define (mod a m) (- a (* (/ a m) m)))
(define (inc x) (+ x 1))
(define (dec x) (- x 1))
(define (adjust-list ls nothing len)
  (let ((flag 0)
        (f (lambda (ls nothing len)
             (if (= 0 len) nothing
               (if (= 0 flag)
                 (cons (car ls)
                       (if (atom? (cdr ls))
                         (begin (set! flag 1) (f ls nothing (dec len)))
                         (f (cdr ls) nothing (dec len))))
                 (cons nothing (f ls nothing (dec len)))
                 )))))
    (f ls nothing len)))
(define (make-tree ls depth)
  (let ((mk (lambda (dep)
              (if (= 0 dep)
                (let ((x (car ls)))
                  (begin (set! ls (cdr ls)) x))
                (cons (mk (- dep 1)) (mk (- dep 1)))))))
    (mk depth)
    )
  )
(define (access-tree t i pow2depth-1) ; 2 の (depth - 1) 乗
  (if (= 0 pow2depth-1)
    t
    (if (> pow2depth-1 i)
      (access-tree (car t) i (/ pow2depth-1 2))
      (access-tree (cdr t) (- i pow2depth-1) (/ pow2depth-1 2)))))

(main (world ghost) (begin
      (cons 99 (lambda (arg)
                 (main (state world) (begin
(let ((seed state)
      (rng (lambda (_) (let ((next (mod (+ (* seed 5) 89219821) 1000000009)))
                         (begin (set! seed next) next))))
      )
  (let ((nstate (rng 0)))
    (cons nstate (mod nstate 4)))
  )
                       ))
                 ))))

